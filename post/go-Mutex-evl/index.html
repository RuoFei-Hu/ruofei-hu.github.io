<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mutexæ¼”åŒ–å² | é£é£çš„Blog</title>
<link rel="shortcut icon" href="https://ruofei-hu.github.io/favicon.ico?v=1684694787815">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://ruofei-hu.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Mutexæ¼”åŒ–å² | é£é£çš„Blog - Atom Feed" href="https://ruofei-hu.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="Mutexçš„è¿›åŒ–å²

å¦‚æœå‡ºç°æ’ç‰ˆé”™ä¹±å¯ä»¥ç‚¹å‡»æˆ‘çš„Notioné“¾æ¥ğŸ”—

1.Mutexè¿›åŒ–çš„æ¦‚è§ˆ

åˆç‰ˆçš„Mutex ä½¿ç”¨ä¸€ä¸ªflag è¡¨ç¤ºå½“å‰æ˜¯å¦è¢«goroutine æ‰€æŒæœ‰ï¼›ä½†æ˜¯å­˜åœ¨ä¸€ä¸ªé—®é¢˜ï¼Œæ–°goroutine ä¼šåœ¨ç­‰å¾…é”é˜Ÿåˆ—çš„å°¾éƒ¨..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://ruofei-hu.github.io">
  <img class="avatar" src="https://ruofei-hu.github.io/images/avatar.png?v=1684694787815" alt="">
  </a>
  <h1 class="site-title">
    é£é£çš„Blog
  </h1>
  <p class="site-description">
    æ¸©æ•…è€ŒçŸ¥æ–°ï¼Œå¯ä»¥è¿›æ­¥çŸ£ã€‚
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          é¦–é¡µ
        </a>
      
    
      
        <a href="/archives" class="menu">
          å½’æ¡£
        </a>
      
    
      
        <a href="/tags" class="menu">
          æ ‡ç­¾
        </a>
      
    
      
        <a href="/post/about" class="menu">
          å…³äº
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Mutexæ¼”åŒ–å²
            </h2>
            <div class="post-info">
              <span>
                2023-04-12
              </span>
              <span>
                16 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="mutexçš„è¿›åŒ–å²">Mutexçš„è¿›åŒ–å²</h1>
<blockquote>
<p>å¦‚æœå‡ºç°æ’ç‰ˆé”™ä¹±å¯ä»¥ç‚¹å‡»<a href="https://ruofei-hu.notion.site/Mutex-af25367ae2ac43258cad7a76c3cfb53b">æˆ‘çš„Notioné“¾æ¥ğŸ”—</a></p>
</blockquote>
<h2 id="1mutexè¿›åŒ–çš„æ¦‚è§ˆ">1.Mutexè¿›åŒ–çš„æ¦‚è§ˆ</h2>
<ol>
<li>åˆç‰ˆçš„<code>Mutex</code> ä½¿ç”¨ä¸€ä¸ª<code>flag</code> è¡¨ç¤ºå½“å‰æ˜¯å¦è¢«<code>goroutine</code> æ‰€æŒæœ‰ï¼›ä½†æ˜¯å­˜åœ¨ä¸€ä¸ªé—®é¢˜ï¼Œæ–°<code>goroutine</code> ä¼šåœ¨ç­‰å¾…é”é˜Ÿåˆ—çš„å°¾éƒ¨ï¼Œå¯¼è‡´è·å¾—é”ğŸ”çš„å‡ ç‡å¾ˆå°ï¼Œè¿™ä¸å…¬å¹³ï¼Œè€Œä¸”ä¹Ÿä¸æ˜¯æ€§èƒ½æœ€ä¼˜çš„é€‰æ‹©ï¼›(PS:æ¥é¹…åŸï¼Œå°±ä¸ºäº†ä¸‰ä»¶äº‹)</li>
<li>ç¬¬äºŒç‰ˆ<code>Mutex</code> å¢åŠ äº†æ–°æ¥<code>goroutine</code> ç«äº‰é”ğŸ”çš„æœºä¼šï¼›</li>
<li>ç¬¬ä¸‰ç‰ˆ<code>Mutex</code> æ¥ç€æ”¹è¿›ï¼Œè®©æ–°æ¥<code>goroutine</code> å’Œåˆšè¢«å”¤é†’(ä¹‹å‰å› ä¸ºå„ç§åŸå› å¯¼è‡´ä¼‘çœ çš„)çš„<code>goroutine</code> æœ‰æ›´å¤šçš„æœºä¼šï¼Œä½†æ˜¯è¿™ä¸ªå¯¼è‡´äº†é¥¥é¥¿é—®é¢˜ï¼›</li>
<li>ç¬¬å››ç‰ˆ<code>Mutex</code> æœ‰å¢åŠ äº†è§£å†³é¥¥é¥¿é—®é¢˜çš„æ–¹æ¡ˆã€‚</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://ruofei-hu.github.io/post-images/1681305768191.png" alt="" loading="lazy"></figure>
<h2 id="2åˆç‰ˆmutex">2.åˆç‰ˆ<code>Mutex</code></h2>
<ol>
<li>
<p>é€šè¿‡ flag å˜é‡ï¼Œæ ‡è®°å½“å‰çš„é”æ˜¯å¦è¢«æŸä¸ª <code>goroutine</code> æŒæœ‰ã€‚</p>
<ol>
<li>å¦‚æœflag çš„å€¼æ˜¯ 1ï¼Œä»£è¡¨é”å·²è¢«æŒæœ‰ï¼Œå…¶å®ƒç«äº‰é”çš„ <code>goroutine</code> åªèƒ½ç­‰å¾…ï¼›</li>
<li>å¦‚æœflag çš„å€¼æ˜¯ 0ï¼Œç«äº‰é”çš„<code>goroutine</code>å°±å¯ä»¥é€šè¿‡ <code>CAS</code>å°† flag è®¾ç½®ä¸º 1ï¼Œæ ‡è¯†é”è¢«å½“å‰çš„ <code>goroutine</code> æ‰€æŒæœ‰ã€‚</li>
</ol>
</li>
<li>
<p>CASæ“ä½œ</p>
<ol>
<li>æŒ‡ä»¤å°†<strong>ç»™å®šçš„å€¼</strong>å’Œ<strong>ä¸€ä¸ªå†…å­˜åœ°å€ä¸­çš„å€¼</strong>è¿›è¡Œæ¯”è¾ƒï¼š
<ol>
<li>å¦‚æœå®ƒä»¬æ˜¯åŒä¸€ä¸ªå€¼ï¼Œå°±ä½¿ç”¨æ–°å€¼æ›¿æ¢å†…å­˜åœ°å€ä¸­çš„å€¼ï¼Œè¿™ä¸ªæ“ä½œæ˜¯<strong>åŸå­æ€§</strong>çš„ï¼›</li>
<li><strong><a href="https://zh.wikipedia.org/wiki/%E6%AF%94%E8%BE%83%E5%B9%B6%E4%BA%A4%E6%8D%A2">æ¯”è¾ƒå¹¶äº¤æ¢(compare and swap, CAS)</a></strong>ï¼Œæ˜¯åŸå­æ“ä½œçš„ä¸€ç§ï¼Œå¯ç”¨äºåœ¨å¤šçº¿ç¨‹ç¼–ç¨‹ä¸­å®ç°<strong>ä¸è¢«æ‰“æ–­çš„æ•°æ®äº¤æ¢æ“ä½œ</strong>ï¼Œä»è€Œ<strong>é¿å…å¤šçº¿ç¨‹åŒæ—¶æ”¹å†™</strong>æŸä¸€æ•°æ®æ—¶ç”±äºæ‰§è¡Œé¡ºåºä¸ç¡®å®šæ€§ä»¥åŠä¸­æ–­çš„ä¸å¯é¢„çŸ¥æ€§<strong>äº§ç”Ÿçš„æ•°æ®ä¸ä¸€è‡´é—®é¢˜</strong>ã€‚ <strong>è¯¥æ“ä½œé€šè¿‡å°†å†…å­˜ä¸­çš„å€¼ä¸æŒ‡å®šæ•°æ®è¿›è¡Œæ¯”è¾ƒï¼Œå½“æ•°å€¼ä¸€æ ·æ—¶å°†å†…å­˜ä¸­çš„æ•°æ®æ›¿æ¢ä¸ºæ–°çš„å€¼ã€‚</strong></li>
<li><strong>åŸå­æ€§</strong>ä¿è¯è¿™ä¸ªæŒ‡ä»¤æ€»æ˜¯åŸºäºæœ€æ–°çš„å€¼è¿›è¡Œè®¡ç®—ï¼Œå¦‚æœåŒæ—¶æœ‰å…¶å®ƒçº¿ç¨‹å·²ç»ä¿®æ”¹äº†è¿™ä¸ªå€¼ï¼Œé‚£ä¹ˆï¼ŒCAS ä¼šè¿”å›å¤±è´¥ã€‚</li>
</ol>
</li>
</ol>
</li>
<li>
<p>å…·ä½“çš„å®ç°</p>
<pre><code>		// CASæ“ä½œï¼Œå½“æ—¶è¿˜æ²¡æœ‰æŠ½è±¡å‡ºatomicåŒ…
    func cas(val *int32, old, new int32) bool
    func semacquire(*int32) // ä¿¡å·é‡ Pæ“ä½œ è·å–èµ„æº
    func semrelease(*int32) // ä¿¡å·é‡ Væ“ä½œ é‡Šæ”¾èµ„æº

    // äº’æ–¥é”çš„ç»“æ„ï¼ŒåŒ…å«ä¸¤ä¸ªå­—æ®µ
    type Mutex struct {
        key  int32 // é”æ˜¯å¦è¢«æŒæœ‰çš„æ ‡è¯†
        sema int32 // ä¿¡å·é‡ä¸“ç”¨ï¼Œç”¨ä»¥é˜»å¡/å”¤é†’goroutine
    }
    
    // ä¿è¯æˆåŠŸåœ¨valä¸Šå¢åŠ deltaçš„å€¼
    func xadd(val *int32, delta int32) (new int32) {
        for {
            v := *val
            if cas(val, v, v+delta) {// casæ“ä½œ
                return v + delta
            }
        }
        panic(&quot;unreached&quot;)
    }
    
    // è¯·æ±‚é”
    func (m *Mutex) Lock() {
        if xadd(&amp;m.key, 1) == 1 { //æ ‡è¯†åŠ 1ï¼Œå¦‚æœç­‰äº1ï¼ŒæˆåŠŸè·å–åˆ°é”
            return
        }
        semacquire(&amp;m.sema) // å¦åˆ™é˜»å¡ç­‰å¾…
    }
    
    func (m *Mutex) Unlock() {
        if xadd(&amp;m.key, -1) == 0 { // å°†æ ‡è¯†å‡å»1ï¼Œå¦‚æœç­‰äº0ï¼Œåˆ™æ²¡æœ‰å…¶å®ƒç­‰å¾…è€…
            return
        }
        semrelease(&amp;m.sema) // å”¤é†’å…¶å®ƒé˜»å¡çš„goroutine
    }
</code></pre>
</li>
<li>
<p>Mutex ç»“æ„ä½“åŒ…å«ä¸¤ä¸ªå­—æ®µï¼š</p>
<p><strong>å­—æ®µ keyï¼š</strong> æ˜¯ä¸€ä¸ª flagï¼Œç”¨æ¥æ ‡è¯†è¿™ä¸ªæ’å¤–é”æ˜¯å¦è¢«æŸä¸ª goroutine æ‰€æŒæœ‰ï¼Œå¦‚æœ key å¤§äºç­‰äº 1ï¼Œè¯´æ˜è¿™ä¸ªæ’å¤–é”å·²ç»è¢«æŒæœ‰ï¼›</p>
<p><strong>å­—æ®µ semaï¼š</strong> æ˜¯ä¸ªä¿¡å·é‡å˜é‡ï¼Œç”¨æ¥æ§åˆ¶ç­‰å¾… goroutine çš„é˜»å¡ä¼‘çœ å’Œå”¤é†’ã€‚</p>
<figure data-type="image" tabindex="2"><img src="https://ruofei-hu.github.io/post-images/1681305779052.png" alt="" loading="lazy"></figure>
<ul>
<li>Unlock æ–¹æ³•å¯ä»¥è¢«ä»»æ„çš„ <code>goroutine</code> è°ƒç”¨é‡Šæ”¾é”ï¼Œå³ä½¿æ˜¯<strong>æ²¡æŒæœ‰è¿™ä¸ªäº’æ–¥é”çš„ goroutine</strong>ï¼Œä¹Ÿå¯ä»¥è¿›è¡Œè¿™ä¸ªæ“ä½œã€‚å¦‚æœè‡ªå·±çš„é”ğŸ”è¢«å…¶ä»–<code>goroutine</code> é‡Šæ”¾äº†ï¼Œä¼šå¯¼è‡´<code>data race</code> é—®é¢˜ã€‚</li>
<li>åœ¨ä½¿ç”¨ Mutex çš„æ—¶å€™ï¼Œå¿…é¡»è¦ä¿è¯ goroutine å°½å¯èƒ½ä¸å»é‡Šæ”¾è‡ªå·±æœªæŒæœ‰çš„é”ï¼Œä¸€å®šè¦éµå¾ªâ€œ<strong>è°ç”³è¯·ï¼Œè°é‡Šæ”¾</strong>â€çš„åŸåˆ™ã€‚</li>
<li>åœ¨Go1.14ä¹‹åï¼Œç”±äºå¯¹<code>defer</code> è¿›è¡Œäº†å†…è”ä¼˜åŒ–ï¼Œä½¿å¾—ä½¿ç”¨<code>defer</code> çš„æ—¶å€™çš„æ€§èƒ½å·®è·å’Œæ­£å¸¸æ‰§è¡Œæ²¡è¾ƒå¤§åŒºåˆ«ï¼Œä¸€èˆ¬æƒ…å†µä¸‹éƒ½é‡‡ç”¨<code>lock</code>,<code>defer unlock</code> æˆå¯¹å‡ºç°ï¼Œå¯ä»¥å¾ˆæœ‰æ•ˆçš„é¿å…å› ä¸ºé”å¼•å‘çš„é—®é¢˜ï¼Œä½†æ˜¯å¦‚æœä¸´ç•ŒåŒºå¾ˆå°ï¼Œè¿˜æ˜¯é‡‡ç”¨ä¸´ç•ŒåŒºé™„è¿‘åŠ é”ï¼Œè§£é”æ¯”è¾ƒå¥½ã€‚</li>
</ul>
</li>
<li>
<p>åˆç‰ˆ<code>Mutex</code> çš„å®ç°å­˜åœ¨ä¸€ä¸‹é—®é¢˜ï¼š</p>
<ol>
<li>è¯·æ±‚é”çš„<code>goroutine</code> éƒ½åœ¨è¿›è¡Œæ’é˜Ÿç­‰å¾…é”ğŸ”ï¼Œå¦‚æœæŠŠé”æŒ‰é¡ºåºåˆ†é…ï¼Œæ€§èƒ½ä¸æ˜¯æœ€ä¼˜çš„ã€‚ä½†æ˜¯å¦‚æœæŠŠé”ğŸ”ç›´æ¥äº¤ç»™æ­£åœ¨CPUä¸Šæ‰§è¡Œçš„<code>goroutine</code>ï¼Œé¿å…äº†ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œå¯ä»¥æ‹¥æœ‰æ›´é«˜çš„æ€§èƒ½ã€‚</li>
</ol>
</li>
</ol>
<h2 id="3ç¬¬äºŒç‰ˆmutex">3.ç¬¬äºŒç‰ˆ<code>Mutex</code></h2>
<ol>
<li>ç¬¬äºŒç‰ˆçš„Mutexåšè¾ƒå¤§çš„è°ƒæ•´</li>
</ol>
<pre><code>type Mutex struct {
        state int32 // å°†keyæ”¹ä¸ºäº†stateï¼Œ
        sema  uint32
    }
    const (
        mutexLocked = 1 &lt;&lt; iota // mutex is locked
        mutexWoken
        mutexWaiterShift = iota
    )
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://ruofei-hu.github.io/post-images/1681305791171.png" alt="" loading="lazy"></figure>
<p><code>state</code>æˆä¸ºäº†ä¸€ä¸ªå¤åˆå­—æ®µï¼š</p>
<ol>
<li>
<p>å­—æ®µç¬¬ä¸€ä½ï¼šè¡¨ç¤ºå½“å‰é”ğŸ”æ˜¯å¦<strong>è¢«æŒæœ‰</strong>ï¼›</p>
</li>
<li>
<p>å­—æ®µç¬¬äºŒä½ï¼šè¡¨ç¤ºå½“å‰æ˜¯å¦<strong>è¢«å”¤é†’</strong>çš„<code>goroutine</code> ï¼›</p>
</li>
<li>
<p>å­—æ®µå‰©ä½™ä½ï¼šè¡¨ç¤ºç­‰å¾…å½“å‰é”ğŸ”çš„<code>goroutine</code>çš„<strong>æ•°é‡ï¼›</strong></p>
</li>
<li>
<p>è¿™æ ·æ”¹åŠ¨çš„åŸå› æ˜¯ä¸ºäº†ä½¿ç”¨æ›´å°‘çš„å†…å­˜ï¼Œå®ç°å¤æ‚çš„äº’æ–¥é”</p>
</li>
<li>
<p>ç¬¬äºŒç‰ˆçš„å…·ä½“å®ç°ï¼š</p>
<pre><code>func (m *Mutex) Lock() {
        // Fast path: å¹¸è¿caseï¼Œèƒ½å¤Ÿç›´æ¥è·å–åˆ°é”

				// é€šè¿‡casæ“ä½œï¼Œæ£€æµ‹stateçš„æ ‡å¿—ä½ã€‚å¦‚æœå½“å‰é”ğŸ”æ²¡æœ‰è¢«æŒæœ‰ä¸”æ— ç­‰å¾…æ­¤é”ğŸ”çš„goroutineï¼Œå½“å‰goroutineå¯ä»¥ç›´æ¥è·å¾—å½“å‰é”ğŸ”
        if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {
            return
        }
				
				// å½“å‰é”ğŸ”å·²è¢«æŒæœ‰æ‰§è¡Œä»¥ä¸‹æ“ä½œ
        awoke := false 

        for {    // å¾ªç¯ä¸æ–­è¯·æ±‚é”ğŸ”ï¼›å®åœ¨è¯·æ±‚ä¸åˆ°é”ğŸ”ï¼Œå°±è°ƒç”¨runtime.Semacquire(&amp;m.sema)è¿›è¡Œä¼‘çœ ï¼Œä¼‘çœ åé†’æ¥åå°†awokeè®¾ç½®ä¸ºtrueï¼Œå°è¯•ç«äº‰é”ğŸ”

            old := m.state
            new := old | mutexLocked // è®¾ç½®æ–°çŠ¶æ€ä¸ºåŠ é”ï¼Œè¿™ä¸ªMutexLockedæ˜¯äººä¸ºå‡è®¾çš„ã€‚åªè¦å®é™…é”æ ‡è¯†ä½ä¸ºå‡ï¼Œé‚£ä¹ˆnewçš„å€¼å°±æ˜¯å‡  æˆ–æ“ä½œï¼Œä¸€å‡å…¨å‡

            if old&amp;mutexLocked != 0 {            // ä¸æ“ä½œï¼Œå…¨çœŸä¸ºçœŸã€‚ å¦‚æœå®é™…é”çš„æ ‡è¯†ä½å€¼å’Œäººä¸ºè®¾ç½®çš„åŠ é”çŠ¶æ€çš„ä¸æ“ä½œç»“æœä¸ä¸ºé›¶ å³å½“å‰é”è¢«æŒæœ‰ï¼Œåˆ™ç­‰å¾…è€…æ•°é‡åŠ ä¸€
                new = old + 1&lt;&lt;mutexWaiterShift //ç­‰å¾…è€…æ•°é‡åŠ ä¸€
            }

            if awoke {
                // goroutineæ˜¯è¢«å”¤é†’çš„ï¼Œ
                // æ–°çŠ¶æ€æ¸…é™¤å”¤é†’æ ‡å¿—
                new &amp;^= mutexWoken
            }

            if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {//è®¾ç½®æ–°çŠ¶æ€ï¼Œ newä¸ºåŠ é”çŠ¶æ€ï¼Œé€šè¿‡casæ“ä½œæŠŠnewèµ‹å€¼ç»™stateï¼Œå°±ä»£è¡¨æŠ¢é”ğŸ”æˆåŠŸ
                if old&amp;mutexLocked == 0 { // é”åŸçŠ¶æ€æœªåŠ é”
                    break
                }
								// å¦‚æœæˆåŠŸåœ°è®¾ç½®äº† state çš„å€¼ï¼Œä½†æ˜¯ä¹‹å‰çš„ state æ˜¯æœ‰é”çš„çŠ¶æ€ï¼Œé‚£ä¹ˆï¼Œstate åªæ˜¯æ¸…é™¤ mutexWoken æ ‡å¿—æˆ–è€…å¢åŠ ä¸€ä¸ª waiter è€Œå·²ã€‚
                runtime.Semacquire(&amp;m.sema) // è¯·æ±‚ä¿¡å·é‡ï¼Œå°†goroutineä¼‘çœ 
                awoke = true
            }
        }
    }

// ps: ç†è§£èµ·æ¥æœ‰ç‚¹è´¹åŠ² QAQ ORZ
</code></pre>
<ol>
<li>
<p>å½“æƒ³è¦è·å–é”çš„<code>goroutine</code>æ²¡èƒ½è·å–åˆ°é”ğŸ”ï¼Œå°±ä¼šè¿›è¡Œä¼‘çœ ï¼›</p>
</li>
<li>
<p>å½“é”ğŸ”é‡Šæ”¾åï¼Œä¼šå°†ä¹‹å‰ç­‰å¾…æ­¤é”ğŸ”çš„<code>goroutine</code>è¿›è¡Œå”¤é†’ï¼›</p>
</li>
<li>
<p><strong>å”¤é†’ä¹‹åçš„<code>goroutine</code></strong> éœ€è¦ å’Œ <strong>æ­£åœ¨è¯·æ±‚å½“å‰é”ğŸ”çš„<code>goroutine</code></strong> <strong>ä¸€èµ·ç«äº‰é”ï¼›</strong></p>
</li>
<li>
<p>åœ¨ä¸€å®šç¨‹åº¦ä¸Šï¼Œå¢åŠ äº†åæ¥è€…çš„æœºä¼šï¼Œä¹Ÿå˜ç›¸çš„æé«˜äº†CPUä¸­æ­£åœ¨æ‰§è¡Œ<code>goroutine</code>è·å¾—é”ğŸ”çš„æœºä¼šï¼Œæé«˜äº†æ€§èƒ½</p>
</li>
<li>
<p>ç«äº‰é”çš„<code>goroutine</code>æœ‰ä¸¤ç§</p>
<ol>
<li>æ–°æ¥çš„</li>
<li>è¢«å”¤é†’çš„</li>
</ol>
</li>
<li>
<p>é”çš„çŠ¶æ€ä¹Ÿæœ‰ä¸¤ç§ï¼š</p>
<ol>
<li>æœªè¢«æŒæœ‰</li>
<li>å·²è¢«æŒæœ‰</li>
</ol>
<table>
<thead>
<tr>
<th>Gç§ç±»</th>
<th>å·²è¢«æŒæœ‰</th>
<th>æœªè¢«æŒæœ‰</th>
</tr>
</thead>
<tbody>
<tr>
<td>æ–°æ¥çš„</td>
<td>waiter++ï¼›ä¼‘çœ </td>
<td>è·å–åˆ°é”ğŸ”</td>
</tr>
<tr>
<td>è¢«å”¤é†’çš„</td>
<td>æ¸…é™¤mutexWokenæ ‡è¯†ä½ï¼›é‡æ–°ä¼‘çœ ï¼ŒåŠ å…¥ç­‰å¾…é˜Ÿåˆ—</td>
<td>æ¸…é™¤mutexWokenæ ‡è¯†ä½ï¼›  è·å–åˆ°é”ğŸ”</td>
</tr>
</tbody>
</table>
</li>
</ol>
<p>é‡Šæ”¾é”</p>
<pre><code>func (m *Mutex) Unlock() {
        // Fast path: drop lock bit.
        new := atomic.AddInt32(&amp;m.state, -mutexLocked) //å»æ‰é”æ ‡å¿—
        if (new+mutexLocked)&amp;mutexLocked == 0 { //æœ¬æ¥å°±æ²¡æœ‰åŠ é”
            panic(&quot;sync: unlock of unlocked mutex&quot;) // å¦‚æœç›´æ¥è§£é”ä¸€ä¸ªæ— é”çŠ¶æ€çš„é”ï¼Œä¼španic
        }

				// å°†é”ğŸ”ç½®ä¸ºæœªè¢«æŒæœ‰çš„çŠ¶æ€
				// ä¹‹åè¿˜éœ€æœ‰ä¸€äº›é€»è¾‘å¤„ç†
    
        old := new
        for {
            if old&gt;&gt;mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken) != 0 { // æ²¡æœ‰ç­‰å¾…è€…ï¼Œæˆ–è€…æœ‰å”¤é†’çš„waiterï¼Œæˆ–è€…é”åŸæ¥å·²åŠ é”
                return
            }
            new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken // æ–°çŠ¶æ€ï¼Œå‡†å¤‡å”¤é†’goroutineï¼Œå¹¶è®¾ç½®å”¤é†’æ ‡å¿—
            if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
                runtime.Semrelease(&amp;m.sema)
                return
            }
            old = m.state
        }
    
</code></pre>
<ol>
<li>æ²¡æœ‰ç­‰å¾…çš„goroutineï¼Œè¯´æ˜å¯¹è¿™ä¸ªé”çš„ç«äº‰çš„ goroutine åªæœ‰ä¸€ä¸ªï¼Œé‚£å°±å¯ä»¥ç›´æ¥è¿”å›äº†ï¼›å¦‚æœè¿™ä¸ªæ—¶åˆ»æœ‰è¢«å”¤é†’çš„ goroutineï¼Œæˆ–è€…é”è¢«åˆ«äººæŒæœ‰äº†ï¼Œä¸ç”¨ç®¡ï¼Œè¿”å›å³å¯ã€‚</li>
<li>æœ‰ç­‰å¾…è€…ï¼Œä½†æ˜¯æ²¡æœ‰è¢«å”¤é†’çš„goroutineï¼Œå°±éœ€è¦å”¤é†’ä¸€ä¸ªã€‚åœ¨å”¤é†’ä¹‹å‰ï¼Œéœ€è¦å°† waiter æ•°é‡å‡ 1ï¼Œå¹¶ä¸”å°† mutexWoken æ ‡å¿—è®¾ç½®ä¸Šï¼Œè¿™æ ·ï¼ŒUnlock å°±å¯ä»¥è¿”å›äº†ã€‚</li>
</ol>
</li>
<li>
<p>è¿™äº›æ”¹åŠ¨éƒ½æ˜¯ä¸ºäº†è®©æ–°çš„goroutineå¢åŠ è·å¾—é”çš„æœºä¼šï¼Œæ”¹å˜äº†å…ˆæ¥å…ˆå¾—çš„è§„åˆ™ã€‚</p>
</li>
</ol>
<h2 id="4ç¬¬ä¸‰ç‰ˆmutex">4.ç¬¬ä¸‰ç‰ˆ<code>Mutex</code></h2>
<ol>
<li>
<p>ä¸ºäº†å†æ¬¡å¢åŠ æ–°æ¥çš„goroutineå’Œè¢«å”¤é†’goroutineè·å¾—é”ğŸ”çš„æœºä¼šï¼Œå¯¹äºæ–°æ¥çš„goroutineæˆ–è€…è¢«å”¤é†’ä¹‹åçš„goroutineï¼Œé¦–æ¬¡æ²¡æœ‰ç«äº‰åˆ°é”ğŸ”ï¼Œè¿™äº›goroutineä¼šå°è¯•è‡ªæ—‹ï¼ˆspinï¼‰ä¸€å®šæ¬¡æ•°ï¼Œæ£€æŸ¥é”ğŸ”æ˜¯å¦è¢«é‡Šæ”¾ï¼Œè¶…è¿‡äº†è¿™ä¸ªæ¬¡æ•°ï¼Œåœ¨ç»§ç»­æ‰§è¡Œä¹‹åçš„é€»è¾‘ã€‚</p>
</li>
<li>
<p>å…·ä½“å®ç°</p>
<pre><code>func (m *Mutex) Lock() {
        // Fast path: å¹¸è¿ä¹‹è·¯ï¼Œæ­£å¥½è·å–åˆ°é”
        if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {
            return
        }
        awoke := false
        iter := 0

        for { // ä¸ç®¡æ˜¯æ–°æ¥çš„è¯·æ±‚é”çš„goroutine, è¿˜æ˜¯è¢«å”¤é†’çš„goroutineï¼Œéƒ½ä¸æ–­å°è¯•è¯·æ±‚é”
            old := m.state // å…ˆä¿å­˜å½“å‰é”çš„çŠ¶æ€
            new := old | mutexLocked // æ–°çŠ¶æ€è®¾ç½®åŠ é”æ ‡å¿—
            if old&amp;mutexLocked != 0 { // é”è¿˜æ²¡è¢«é‡Šæ”¾
                if runtime_canSpin(iter) { // è¿˜å¯ä»¥è‡ªæ—‹
                    if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old&gt;&gt;mutexWaiterShift != 0 &amp;&amp;
                        atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {
                        awoke = true
                    }
                    runtime_doSpin()
                    iter++
                    continue // è‡ªæ—‹ï¼Œå†æ¬¡å°è¯•è¯·æ±‚é”
                }
                new = old + 1&lt;&lt;mutexWaiterShift
            }
            if awoke { // å”¤é†’çŠ¶æ€
                if new&amp;mutexWoken == 0 {
                    panic(&quot;sync: inconsistent mutex state&quot;)
                }
                new &amp;^= mutexWoken // æ–°çŠ¶æ€æ¸…é™¤å”¤é†’æ ‡è®°
            }
            if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
                if old&amp;mutexLocked == 0 { // æ—§çŠ¶æ€é”å·²é‡Šæ”¾ï¼Œæ–°çŠ¶æ€æˆåŠŸæŒæœ‰äº†é”ï¼Œç›´æ¥è¿”å›
                    break
                }
                runtime_Semacquire(&amp;m.sema) // é˜»å¡ç­‰å¾…
                awoke = true // è¢«å”¤é†’
                iter = 0
            }
        }
    }
</code></pre>
<p>ä¸´ç•ŒåŒºçš„ä»£ç è€—æ—¶å¾ˆçŸ­ï¼Œé”å¾ˆå¿«å°±èƒ½é‡Šæ”¾ï¼Œè€ŒæŠ¢å¤ºé”çš„ goroutine ä¸ç”¨é€šè¿‡ä¼‘çœ å”¤é†’æ–¹å¼ç­‰å¾…è°ƒåº¦ï¼Œ spin å‡ æ¬¡ï¼Œå°±æœ‰å¯èƒ½å°±è·å¾—äº†é”ï¼Œæœºä¼šä¸€ä¸‹æ¬¡å¢åŠ å¾ˆå¤šã€‚</p>
</li>
</ol>
<h2 id="5ç¬¬å››ç‰ˆmutex">5.ç¬¬å››ç‰ˆ<code>Mutex</code></h2>
<ol>
<li>
<p>ç”±äºç¬¬äºŒç‰ˆå’Œç¬¬ä¸‰ç‰ˆä¸ºæ–°æ¥çš„ goroutineå¢åŠ äº†è·å–åˆ°é”çš„æœºä¼šï¼Œåœ¨æç«¯æƒ…å†µä¸‹ï¼Œç­‰å¾…ä¸­çš„ goroutine å¯èƒ½ä¼šä¸€ç›´è·å–ä¸åˆ°é”ï¼Œè¿™å°±æ˜¯<strong>é¥¥é¥¿é—®é¢˜</strong>ã€‚Go 1.9 ä¸­ Mutex å¢åŠ äº†é¥¥é¥¿æ¨¡å¼ï¼Œè®©é”çš„ç«äº‰å˜å¾—æ›´å…¬å¹³ï¼Œå°†ç­‰å¾…æ—¶é—´æœ€å¤§æ—¶é—´è®¾ç½®ä¸º 1 msï¼Œå¹¶ä¸”ä¿®å¤äº†ä¸€ä¸ªå¤§ Bugï¼šè°ƒåº¦æ€»æ˜¯æŠŠå”¤é†’çš„ goroutine æ”¾åœ¨ç­‰å¾…é˜Ÿåˆ—çš„å°¾éƒ¨ï¼Œä¼šå¯¼è‡´æ›´ä¹…çš„ç­‰å¾…æ—¶é—´ã€‚</p>
<p>2018 å¹´ï¼ŒGo å›¢é˜Ÿå°† fast path å’Œ slow path æ‹†æˆç‹¬ç«‹çš„æ–¹æ³•ï¼Œä»¥ä¾¿å†…è”ï¼Œæé«˜æ€§èƒ½ã€‚2019 å¹´ä¹Ÿæœ‰ä¸€ä¸ª Mutex çš„ä¼˜åŒ–ï¼Œè™½ç„¶æ²¡æœ‰å¯¹ Mutex åšä¿®æ”¹ï¼Œä½†æ˜¯ï¼Œå¯¹äº Mutex å”¤é†’åæŒæœ‰é”çš„é‚£ä¸ª waiterï¼Œè°ƒåº¦å™¨å¯ä»¥æœ‰æ›´é«˜çš„ä¼˜å…ˆçº§å»æ‰§è¡Œã€‚</p>
</li>
</ol>
<figure data-type="image" tabindex="4"><img src="https://ruofei-hu.github.io/post-images/1681305807685.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>
<p>å…·ä½“çš„å®ç°</p>
<pre><code>type Mutex struct {
        state int32
        sema  uint32
    }
    
    const (
        mutexLocked = 1 &lt;&lt; iota // mutex is locked
        mutexWoken
        mutexStarving // ä»stateå­—æ®µä¸­åˆ†å‡ºä¸€ä¸ªé¥¥é¥¿æ ‡è®°
        mutexWaiterShift = iota
    
        starvationThresholdNs = 1e6 // å°†é¥¥é¥¿æ—¶é—´è®¾ç½®ä¸º1ms
    )
    
    func (m *Mutex) Lock() {
        // Fast path: å¹¸è¿ä¹‹è·¯ï¼Œä¸€ä¸‹å°±è·å–åˆ°äº†é”
        if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {
            return
        }
        // Slow pathï¼šç¼“æ…¢ä¹‹è·¯ï¼Œå°è¯•è‡ªæ—‹ç«äº‰æˆ–é¥¥é¥¿çŠ¶æ€ä¸‹é¥¥é¥¿goroutineç«äº‰
        m.lockSlow()
    }
    
    func (m *Mutex) lockSlow() {
        var waitStartTime int64
        starving := false // æ­¤goroutineçš„é¥¥é¥¿æ ‡è®°
        awoke := false // å”¤é†’æ ‡è®°
        iter := 0 // è‡ªæ—‹æ¬¡æ•°
        old := m.state // å½“å‰çš„é”çš„çŠ¶æ€
        for {
            // é”æ˜¯éé¥¥é¥¿çŠ¶æ€ï¼Œé”è¿˜æ²¡è¢«é‡Šæ”¾ï¼Œå°è¯•è‡ªæ—‹
            if old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) {
                if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old&gt;&gt;mutexWaiterShift != 0 &amp;&amp;
                    atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {
                    awoke = true
                }
                runtime_doSpin()
                iter++
                old = m.state // å†æ¬¡è·å–é”çš„çŠ¶æ€ï¼Œä¹‹åä¼šæ£€æŸ¥æ˜¯å¦é”è¢«é‡Šæ”¾äº†
                continue
            }
            new := old
            if old&amp;mutexStarving == 0 {
                new |= mutexLocked // éé¥¥é¥¿çŠ¶æ€ï¼ŒåŠ é”
            }
            if old&amp;(mutexLocked|mutexStarving) != 0 {
                new += 1 &lt;&lt; mutexWaiterShift // waiteræ•°é‡åŠ 1
            }
            if starving &amp;&amp; old&amp;mutexLocked != 0 {
                new |= mutexStarving // è®¾ç½®é¥¥é¥¿çŠ¶æ€
            }
            if awoke {
                if new&amp;mutexWoken == 0 {
                    throw(&quot;sync: inconsistent mutex state&quot;)
                }
                new &amp;^= mutexWoken // æ–°çŠ¶æ€æ¸…é™¤å”¤é†’æ ‡è®°
            }
            // æˆåŠŸè®¾ç½®æ–°çŠ¶æ€
            if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
                // åŸæ¥é”çš„çŠ¶æ€å·²é‡Šæ”¾ï¼Œå¹¶ä¸”ä¸æ˜¯é¥¥é¥¿çŠ¶æ€ï¼Œæ­£å¸¸è¯·æ±‚åˆ°äº†é”ï¼Œè¿”å›
                if old&amp;(mutexLocked|mutexStarving) == 0 {
                    break // locked the mutex with CAS
                }
                // å¤„ç†é¥¥é¥¿çŠ¶æ€
                // å¦‚æœä»¥å‰å°±åœ¨é˜Ÿåˆ—é‡Œé¢ï¼ŒåŠ å…¥åˆ°é˜Ÿåˆ—å¤´
                queueLifo := waitStartTime != 0
                if waitStartTime == 0 {
                    waitStartTime = runtime_nanotime()
                }
                // é˜»å¡ç­‰å¾…
                runtime_SemacquireMutex(&amp;m.sema, queueLifo, 1)
                // å”¤é†’ä¹‹åæ£€æŸ¥é”æ˜¯å¦åº”è¯¥å¤„äºé¥¥é¥¿çŠ¶æ€
                starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs
                old = m.state
                // å¦‚æœé”å·²ç»å¤„äºé¥¥é¥¿çŠ¶æ€ï¼Œç›´æ¥æŠ¢åˆ°é”ï¼Œè¿”å›
                if old&amp;mutexStarving != 0 {
                    if old&amp;(mutexLocked|mutexWoken) != 0 || old&gt;&gt;mutexWaiterShift == 0 {
                        throw(&quot;sync: inconsistent mutex state&quot;)
                    }
                    // æœ‰ç‚¹ç»•ï¼ŒåŠ é”å¹¶ä¸”å°†waiteræ•°å‡1
                    delta := int32(mutexLocked - 1&lt;&lt;mutexWaiterShift)
                    if !starving || old&gt;&gt;mutexWaiterShift == 1 {
                        delta -= mutexStarving // æœ€åä¸€ä¸ªwaiteræˆ–è€…å·²ç»ä¸é¥¥é¥¿äº†ï¼Œæ¸…é™¤é¥¥é¥¿æ ‡è®°
                    }
                    atomic.AddInt32(&amp;m.state, delta)
                    break
                }
                awoke = true
                iter = 0
            } else {
                old = m.state
            }
        }
    }
    
    func (m *Mutex) Unlock() {
        // Fast path: drop lock bit.
        new := atomic.AddInt32(&amp;m.state, -mutexLocked)
        if new != 0 {
            m.unlockSlow(new)
        }
    }
    
    func (m *Mutex) unlockSlow(new int32) {
        if (new+mutexLocked)&amp;mutexLocked == 0 {
            throw(&quot;sync: unlock of unlocked mutex&quot;)
        }
        if new&amp;mutexStarving == 0 {
            old := new
            for {
                if old&gt;&gt;mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken|mutexStarving) != 0 {
                    return
                }
                new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken
                if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
                    runtime_Semrelease(&amp;m.sema, false, 1)
                    return
                }
                old = m.state
            }
        } else {
            runtime_Semrelease(&amp;m.sema, true, 1)
        }
    }
</code></pre>
<p>ç¬¬å››ç‰ˆçš„ Mutex æœ€é‡è¦çš„å˜åŒ–ï¼Œå°±æ˜¯å¢åŠ é¥¥é¥¿æ¨¡å¼ã€‚å°†é¥¥é¥¿æ¨¡å¼çš„æœ€å¤§ç­‰å¾…æ—¶é—´é˜ˆå€¼è®¾ç½®æˆäº† 1 æ¯«ç§’ï¼Œä¸€æ—¦ç­‰å¾…è€…ç­‰å¾…çš„æ—¶é—´è¶…è¿‡äº†è¿™ä¸ªé˜ˆå€¼ï¼ŒMutex çš„å¤„ç†å°±æœ‰å¯èƒ½è¿›å…¥é¥¥é¥¿æ¨¡å¼ï¼Œä¼˜å…ˆè®©ç­‰å¾…è€…å…ˆè·å–åˆ°é”ã€‚é€šè¿‡åŠ å…¥é¥¥é¥¿æ¨¡å¼ï¼Œå¯ä»¥é¿å…æŠŠæœºä¼šå…¨éƒ½ç•™ç»™æ–°æ¥çš„ goroutineï¼Œä¿è¯äº†è¯·æ±‚é”çš„ goroutine è·å–é”çš„å…¬å¹³æ€§ã€‚</p>
<ol>
<li>
<p>å¯¹æ¯”é¥¥é¥¿æ¨¡å¼å’Œæ­£å¸¸æ¨¡å¼</p>
<ol>
<li>è¯·æ±‚é”æ—¶è°ƒç”¨çš„ Lock æ–¹æ³•ä¸­ä¸€å¼€å§‹æ˜¯ fast pathï¼Œå½“å‰çš„ goroutine å¹¸è¿åœ°è·å¾—äº†é”ï¼Œæ²¡æœ‰ç«äº‰ï¼Œç›´æ¥è¿”å›ï¼Œå¦åˆ™å°±è¿›å…¥äº† lockSlow æ–¹æ³•ã€‚è¿™æ ·çš„è®¾è®¡ï¼Œæ–¹ä¾¿ç¼–è¯‘å™¨å¯¹ Lock æ–¹æ³•è¿›è¡Œå†…è”.</li>
<li>æ­£å¸¸æ¨¡å¼ä¸‹ï¼Œwaiter éƒ½æ˜¯è¿›å…¥å…ˆå…¥å…ˆå‡ºé˜Ÿåˆ—ï¼Œè¢«å”¤é†’çš„ waiter å¹¶ä¸ä¼šç›´æ¥æŒæœ‰é”ï¼Œè€Œæ˜¯è¦å’Œæ–°æ¥çš„ goroutine è¿›è¡Œç«äº‰ã€‚æ–°æ¥çš„ goroutine æœ‰å…ˆå¤©çš„ä¼˜åŠ¿ï¼Œå®ƒä»¬æ­£åœ¨ CPU ä¸­è¿è¡Œï¼Œå¯èƒ½å®ƒä»¬çš„æ•°é‡è¿˜ä¸å°‘ï¼Œæ‰€ä»¥ï¼Œåœ¨é«˜å¹¶å‘æƒ…å†µä¸‹ï¼Œè¢«å”¤é†’çš„ waiter å¯èƒ½æ¯”è¾ƒæ‚²å‰§åœ°è·å–ä¸åˆ°é”ï¼Œè¿™æ—¶ï¼Œå®ƒä¼šè¢«æ’å…¥åˆ°é˜Ÿåˆ—çš„å‰é¢ã€‚å¦‚æœ waiter è·å–ä¸åˆ°é”çš„æ—¶é—´è¶…è¿‡é˜ˆå€¼ 1 msï¼Œé‚£ä¹ˆï¼Œè¿™ä¸ª Mutex å°±è¿›å…¥åˆ°äº†é¥¥é¥¿æ¨¡å¼ã€‚</li>
<li>åœ¨é¥¥é¥¿æ¨¡å¼ä¸‹ï¼ŒMutex çš„æ‹¥æœ‰è€…å°†ç›´æ¥æŠŠé”äº¤ç»™é˜Ÿåˆ—æœ€å‰é¢çš„ waiterã€‚æ–°æ¥çš„ goroutine ä¸ä¼šå°è¯•è·å–é”ï¼Œå³ä½¿çœ‹èµ·æ¥é”æ²¡æœ‰è¢«æŒæœ‰ï¼Œå®ƒä¹Ÿä¸ä¼šå»æŠ¢ï¼Œä¹Ÿä¸ä¼š spinï¼Œå®ƒä¼šä¹–ä¹–åœ°åŠ å…¥åˆ°ç­‰å¾…é˜Ÿåˆ—çš„å°¾éƒ¨ã€‚</li>
<li>æŒæœ‰ Mutex çš„ waiter å‘ç°ä¸‹é¢ä¸¤ç§æƒ…å†µçš„å…¶ä¸­ä¹‹ä¸€ï¼Œå®ƒå°±ä¼šæŠŠè¿™ä¸ª Mutex è½¬æ¢æˆæ­£å¸¸æ¨¡å¼:</li>
</ol>
<ul>
<li>æ­¤ waiter å·²ç»æ˜¯é˜Ÿåˆ—ä¸­çš„æœ€åä¸€ä¸ª waiter äº†ï¼Œæ²¡æœ‰å…¶å®ƒçš„ç­‰å¾…é”çš„ goroutine äº†ï¼›</li>
<li>æ­¤ waiter çš„ç­‰å¾…æ—¶é—´å°äº 1 æ¯«ç§’ã€‚<br>
æ­£å¸¸æ¨¡å¼æ‹¥æœ‰æ›´å¥½çš„æ€§èƒ½ï¼Œå› ä¸ºå³ä½¿æœ‰ç­‰å¾…æŠ¢é”çš„ waiterï¼Œgoroutine ä¹Ÿå¯ä»¥è¿ç»­å¤šæ¬¡è·å–åˆ°é”ã€‚<br>
é¥¥é¥¿æ¨¡å¼æ˜¯å¯¹å…¬å¹³æ€§å’Œæ€§èƒ½çš„ä¸€ç§å¹³è¡¡ï¼Œå®ƒé¿å…äº†æŸäº› goroutine é•¿æ—¶é—´çš„ç­‰å¾…é”ã€‚åœ¨é¥¥é¥¿æ¨¡å¼ä¸‹ï¼Œä¼˜å…ˆå¯¹å¾…çš„æ˜¯é‚£äº›ä¸€ç›´åœ¨ç­‰å¾…çš„ waiterã€‚</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="6æ€»ç»“">6.æ€»ç»“</h2>
<ol>
<li>æœ€ç»ˆstateå­—æ®µè¢«ç“œåˆ†ä¸ºå››éƒ¨åˆ†ï¼š
<ol>
<li>æ˜¯å¦è¢«æŒæœ‰</li>
<li>æ˜¯å¦è¢«å”¤é†’</li>
<li>æ˜¯å¦é¥¥é¥¿</li>
<li>å‰©ä½™ç­‰å¾…çš„goroutineæ•°é‡</li>
</ol>
</li>
<li>å½“ç«äº‰é”ğŸ”çš„goroutineç­‰å¾…æ—¶é•¿è¶…å¤š1msï¼Œå°±è½¬æ¢ä¸ºé¥¥é¥¿æ¨¡å¼ï¼Œå½“å‰ç­‰å¾…é˜Ÿåˆ—çš„ç¬¬ä¸€ä¸ªwaiterï¼Œç›´æ¥è·å¾—é”ğŸ”</li>
<li>å½“æŒæœ‰é”ğŸ”çš„goroutineå‘ç°è‡ªå·±ï¼š
<ol>
<li>æ˜¯è¿™ä¸ªç«äº‰é”ğŸ”é˜Ÿåˆ—æœ€åä¸€ä¸ªï¼Œå°†ä¼šæŠŠé”ä»é¥¥é¥¿æ¨¡å¼è½¬ä¸ºæ­£å¸¸æ¨¡å¼</li>
<li>ç­‰å¾…é”çš„æ—¶é—´å°äº1msï¼Œä¼šå°†é”ä»é¥¥é¥¿æ¨¡å¼è½¬ä¸ºæ­£å¸¸æ¨¡å¼</li>
</ol>
</li>
<li>æ­£å¸¸æ¨¡å¼æ‹¥æœ‰æ›´é«˜çš„æ€§èƒ½ï¼›åŠ å…¥äº†é¥¥é¥¿æ¨¡å¼ä¼šæ›´åŠ å…¬å¹³</li>
</ol>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#mutex%E7%9A%84%E8%BF%9B%E5%8C%96%E5%8F%B2">Mutexçš„è¿›åŒ–å²</a>
<ul>
<li><a href="#1mutex%E8%BF%9B%E5%8C%96%E7%9A%84%E6%A6%82%E8%A7%88">1.Mutexè¿›åŒ–çš„æ¦‚è§ˆ</a></li>
<li><a href="#2%E5%88%9D%E7%89%88mutex">2.åˆç‰ˆ<code>Mutex</code></a></li>
<li><a href="#3%E7%AC%AC%E4%BA%8C%E7%89%88mutex">3.ç¬¬äºŒç‰ˆ<code>Mutex</code></a></li>
<li><a href="#4%E7%AC%AC%E4%B8%89%E7%89%88mutex">4.ç¬¬ä¸‰ç‰ˆ<code>Mutex</code></a></li>
<li><a href="#5%E7%AC%AC%E5%9B%9B%E7%89%88mutex">5.ç¬¬å››ç‰ˆ<code>Mutex</code></a></li>
<li><a href="#6%E6%80%BB%E7%BB%93">6.æ€»ç»“</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">ä¸‹ä¸€ç¯‡</div>
            <a href="https://ruofei-hu.github.io/post/mysql/">
              <h3 class="post-title">
                 MySQLæ•°æ®åº“è°ƒä¼˜çŸ¥è¯†
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://ruofei-hu.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
